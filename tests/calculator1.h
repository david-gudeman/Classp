/* BEGIN HEADER */
#ifndef calculator1_INCLUDE_
#define calculator1_INCLUDE_

#include <assert.h>
#include <unordered_map>
#include <utility>

#include "classp.h"

// Include files generated by bison
#include "calculator1.yacc.hh"
#include "location.hh"
#include "position.hh"

namespace calculator1 {
using std::istream;
using std::ostream;
using classp::classpPrint;
using classp::classpFormat;
using classp::AttributeMap;

// Location and state information from the parser.
typedef location ParseState;

extern ParseState defaultParseState;

class AstNode;
/* BEGIN FORWARD DECLARATIONS */
class Binop;
class Diff;
class Div;
class Expression;
class IntegerLiteral;
class Negate;
class Prod;
class Sum;
/* END FORWARD DECLARATIONS */

// Base class for calculator1 AST nodes
class AstNode : public classp::ClasspNode {
 public:
  string className() override { return "AstNode"; }
  AstNode(ParseState parseState)
    : parseState(parseState) {
    }

  // Write out a bracketed form of this AST from the declared syntax.
  virtual void bracketFormat(std::ostream& out, AstNode* self) {
    assert(false);
  }

  ParseState parseState;
};

/* BEGIN CLASS DEFINITIONS */
class Expression: public AstNode {
 public:
  string className() override { return "Expression"; }
  Expression(ParseState parseState);
  static Expression* parse(istream& input, ostream& errors);
  void printMembers(ostream& out) override;
  void bracketFormat(ostream& out, AstNode* self) override;

};

class Negate: public Expression {
 public:
  string className() override { return "Negate"; }
  Negate(ParseState parseState, Expression* arg);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

  Expression* arg = nullptr;
};

class Binop: public Expression {
 public:
  string className() override { return "Binop"; }
  Binop(ParseState parseState, Expression* arg1, Expression* arg2);
  void printMembers(ostream& out) override;

  Expression* arg1 = nullptr;
  Expression* arg2 = nullptr;
};

class Sum: public Binop {
 public:
  string className() override { return "Sum"; }
  Sum(ParseState parseState, Expression* arg1, Expression* arg2);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

};

class Diff: public Binop {
 public:
  string className() override { return "Diff"; }
  Diff(ParseState parseState, Expression* arg1, Expression* arg2);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

};

class Prod: public Binop {
 public:
  string className() override { return "Prod"; }
  Prod(ParseState parseState, Expression* arg1, Expression* arg2);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

};

class Div: public Binop {
 public:
  string className() override { return "Div"; }
  Div(ParseState parseState, Expression* arg1, Expression* arg2);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

};

class IntegerLiteral: public Expression {
 public:
  string className() override { return "IntegerLiteral"; }
  IntegerLiteral(ParseState parseState, int n);
  void printMembers(ostream& out) override;
  void format(ostream& out, int precedence) override;

  int n;
};
/* END CLASS DEFINITIONS */

}  // namespace calculator1
#endif // calculator1_INCLUDE_

/* END HEADER */
